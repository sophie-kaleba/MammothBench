Model subclass: #GCBenchConfigurator	instanceVariableNames: 'options allocatedObjectsArray allocatedObjectsTree'	classVariableNames: ''	poolDictionaries: ''	category: 'CogTools-GCBenchGenerator'!!GCBenchConfigurator methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 15:46'!options	^ options! !!GCBenchConfigurator methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 15:53'!allocate: stateHeap	| logicalTime quantumAux totalToAllocate numClasses numCompiled numDataObj numWeak class |		class := WordArray variableWordSubclass: (#WordArray , 1) asSymbol						instanceVariableNames: ''						classVariableNames: ''						poolDictionaries: ''						category: 'Collections-Arrayed'.	logicalTime := 0.	totalToAllocate := options timeQuantum * options benchmarkDuration.	"is this possible --> assert" 			"100% (potentially a bit less) of the wanted allocated size will be filled with the following number of objects"	"TODO - move this into a specific method"		"TODO - check the actual size of the objects that will be allocated"	numDataObj := self computeNumOf: 16 percentage: options dataObjects of: options timeQuantum.	numClasses :=  self computeNumOf: 16 percentage: options classes of: options timeQuantum.	numWeak := self computeNumOf: 16 percentage: options weakStructures of: options timeQuantum .	numCompiled := self computeNumOf: 16 percentage: options compiledMethods of: options timeQuantum .		logicalTime < options benchmarkDuration whileTrue: [		quantumAux := 0.		quantumAux < options timeQuantum whileTrue: [						self allocateAsArrayWithDataObj: numDataObj weakStructs: numWeak classes: numClasses compiledMethods: numCompiled. 			]]		! !!GCBenchConfigurator methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 10:58'!allocateAsTree	'allocate objects on heap. Each allocated object will be a node of a tree'! !!GCBenchConfigurator methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 15:34'!allocatedObjectsArray	^ allocatedObjectsArray! !!GCBenchConfigurator methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 15:45'!run: stateHeap	self allocate: stateHeap.! !!GCBenchConfigurator methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 15:35'!allocatedObjectsArray: anOrderredCollection	allocatedObjectsArray := anOrderredCollection! !!GCBenchConfigurator methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 15:52'!options: aGcBenchOptionsInstance	options:=aGcBenchOptionsInstance.	allocatedObjectsArray := OrderedCollection new.! !!GCBenchConfigurator methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 11:11'!deallocate! !!GCBenchConfigurator methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 15:53'!computeNumOf: anObjectTypeSize percentage: aPercentage of: totalAllocatedMemory 	"Considering the size of an object, compute how many objects need to be allocated per timeQuantum to meet the memory requirements"		^ ((totalAllocatedMemory * aPercentage) / anObjectTypeSize) floor		! !!GCBenchConfigurator methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 10:55'!traverse: anObjectsStructure! !!GCBenchConfigurator methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 15:39'!allocateAsArrayWithDataObj: numDataObj weakStructs: numWeak classes: numClasses compiledMethods: numCompiled	"allocate objects on heap. Each allocated object will be an element of an array"		| class |	1 to: numDataObj do: [:i | allocatedObjectsArray add: (ByteArray new: 42)].	1 to: numClasses do: [:i | allocatedObjectsArray add: (class)].	1 to: numWeak do: [:i | allocatedObjectsArray add: (class)].	1 to: numCompiled do: [:i | allocatedObjectsArray add: (class)].	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GCBenchConfigurator class	instanceVariableNames: ''!!GCBenchConfigurator class methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 15:51'!runDefault	"stable heap"	| opt |	opt := GCBenchOptions default.	GCBenchConfigurator new		options: opt;		run: opt stateHeap.! !!GCBenchConfigurator class methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 15:49'!runCustom: aGCBenchOptionInstance	| opt |	opt := 	aGCBenchOptionInstance. 	GCBenchConfigurator new		options: opt ;		run: opt stateHeap.! !Model subclass: #GCBenchEvaluator	instanceVariableNames: 'startTime stopTime startVMParameters stopVMParameters'	classVariableNames: ''	poolDictionaries: ''	category: 'CogTools-GCBenchGenerator'!!GCBenchEvaluator commentStamp: 'ClementBera 6/13/2018 16:47' prior: 0!Tool used to measure the behavior of the GC.Example: (GCBenchEvaluator evaluate: [ (1 to: 10000000) collect: [ :i | Object new ] ]) inspect!!GCBenchEvaluator methodsFor: 'parameters' stamp: 'ClementBera 6/13/2018 16:27'!getVMParameters	^ (Smalltalk version includesSubstring: 'Pharo') 		ifTrue: [Smalltalk vm getParameters]		ifFalse: [Smalltalk getVMParameters]! !!GCBenchEvaluator methodsFor: 'report' stamp: 'ClementBera 6/13/2018 16:55'!execTimeMetric	^ {'Total execution time' . 		startTime asMilliSeconds . 		stopTime asMilliSeconds . 		(stopTime asMilliSeconds - startTime asMilliSeconds)}! !!GCBenchEvaluator methodsFor: 'report' stamp: 'ClementBera 6/13/2018 16:53'!interestingMetrics	^ #(	03 'Heap size diff'	07 'num full GCs' 	08 'time spent in full GCs'	09 'num scavenges'	10 'time spent in scavenges'	18 'time spent in compaction'	22 'num remembered table overflow'	31 'num of grow memory request'	32 'num of shrink memory request'	53 'number of segments diff'	53 'size of free old space diff'	)! !!GCBenchEvaluator methodsFor: 'report' stamp: 'ClementBera 6/13/2018 18:00'!computeStats	^ { (stopTime asMilliSeconds - startTime asMilliSeconds).	"total execution time"		(stopVMParameters at: 10) - (startVMParameters at: 10) . "time spent in scavenge"		(stopVMParameters at: 08) - (startVMParameters at: 08) . "time spent in full gc"		(stopVMParameters at: 18) - (startVMParameters at: 18) } "time spent in compaction"		"	'^{self execTimeMetric} , 	(self interestingMetrics pairsCollect: [ :index :string |		{ string . startVMParameters at: index . stopVMParameters at: index . ((stopVMParameters at: index) - (startVMParameters at: index)) }])'"	! !!GCBenchEvaluator methodsFor: 'evaluation' stamp: 'ClementBera 6/13/2018 16:27'!saveStopMetrics	stopTime := Time now.	stopVMParameters := self getVMParameters! !!GCBenchEvaluator methodsFor: 'evaluation' stamp: 'ClementBera 6/13/2018 16:27'!saveStartMetrics	startVMParameters := self getVMParameters.	startTime := Time now.! !!GCBenchEvaluator methodsFor: 'evaluation' stamp: 'ClementBera 6/14/2018 14:49'!evaluate: aBlock	self saveStartMetrics.	aBlock value.	self saveStopMetrics.	^ self computeStats! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GCBenchEvaluator class	instanceVariableNames: ''!!GCBenchEvaluator class methodsFor: 'as yet unclassified' stamp: 'ClementBera 10/3/2018 18:19'!runReference: projectSymbol	| b ev |	b := GCMooseBench new.	ev := GCBenchEvaluator new.	(FileStream fileNamed: projectSymbol , 'reference') 		<< '	load'		<< (ev evaluate: [b benchLoadFromMSE: (b perform: projectSymbol)]) asString		<< '	exp'		<< (ev evaluate: [b benchExpandProperties]) asString		<< '	expWCache'		<< (ev evaluate: [b benchExpandProperties]) asString		<<'	expRelease'		<< (ev evaluate: [b benchRelease]) asString! !!GCBenchEvaluator class methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 13:42'!evaluate: aBlock	^ GCBenchEvaluator new		evaluate: aBlock.! !Model subclass: #GCBenchEvaluatorV2	instanceVariableNames: 'numGCStart numGCEnd time markTimeStart markTimeEnd'	classVariableNames: ''	poolDictionaries: ''	category: 'CogTools-GCBenchGenerator'!!GCBenchEvaluatorV2 commentStamp: 'ClementBera 10/3/2018 18:13' prior: 0!Special version for hacked tracking VM!!GCBenchEvaluatorV2 methodsFor: 'benchmarking' stamp: 'ClementBera 8/1/2018 16:12'!stat: data	^ String streamContents: [:s | 		s 				<< (self conv: data min)			<<  ' < ' 			<< (self conv:  data average)			<< ' < ' 			<< (self conv: data max)			<< '['			<< (data collect: #asFloat) asString			<< ']' ]! !!GCBenchEvaluatorV2 methodsFor: 'benchmarking' stamp: 'ClementBera 7/31/2018 15:50'!read: data at: i	^ (data at: i) + ((data at: i + 1) << 32)! !!GCBenchEvaluatorV2 methodsFor: 'benchmarking' stamp: 'ClementBera 8/1/2018 15:04'!conv: data	^ data asFloat printShowingDecimalPlaces: 2! !!GCBenchEvaluatorV2 methodsFor: 'benchmarking' stamp: 'ClementBera 7/31/2018 15:50'!requirement	Smalltalk specialObjectsArray size = 61 ifFalse: 		[Smalltalk specialObjectsArray becomeForward: (Smalltalk specialObjectsArray , {(WordArray new: 14001) at: 1 put: 1; yourself})].	self assert: Smalltalk specialObjectsArray size = 61.! !!GCBenchEvaluatorV2 methodsFor: 'benchmarking' stamp: 'ClementBera 8/2/2018 07:18'!bench: aBlock	self requirement.		markTimeStart := Smalltalk vm parameterAt: 72.	numGCStart := Smalltalk vm parameterAt: 7.	time := aBlock timeToRunWithoutGC.	numGCEnd := Smalltalk vm parameterAt: 7.	markTimeEnd := Smalltalk vm parameterAt: 72.		^ self computeStats! !!GCBenchEvaluatorV2 methodsFor: 'benchmarking' stamp: 'ClementBera 8/2/2018 07:18'!computeStats	| numFGC data idx incr parsedData sz percent |	numFGC := numGCEnd - numGCStart.	data := Smalltalk specialObjectsArray at: 61.	idx := ((self read: data at: 1)) * 2 + 1.	incr := 1.	sz := (Smalltalk vm parameterAt: 76)		ifTrue: [7]		ifFalse: [5].	parsedData := (1 to: sz) collect: [:i | Array new: numFGC ].	percent := Array new: numFGC.		numFGC timesRepeat: 		[ | gcStart markEnd compactionStart sweepEnd hackStart hackEnd hackUpdateEnd gcEnd |		 idx := idx - 16.		 gcStart := self read: data at: idx.		 markEnd := self read: data at: idx+2.		 compactionStart := self read: data at: idx+4.		 sweepEnd := self read: data at: idx+6.		 hackStart := self read: data at: idx+8. "if no hack, right after compaction"		 hackEnd := self read: data at: idx+10. "0 if no compaction or no hack"		 hackUpdateEnd := self read: data at: idx+12.  "0 if no compaction or no hack"		 gcEnd := self read: data at: idx+14.				 "MarkingTime"		 (parsedData at: 1) at: incr put: markEnd - gcStart.		 "scavenge"		 (parsedData at: 2) at: incr put: compactionStart - markEnd.		 "sweep"		 (parsedData at: 3) at: incr put: sweepEnd - compactionStart.		 "compaction (might be 0)"		 (parsedData at: 4) at: incr put: (hackStart < sweepEnd ifTrue: [0] ifFalse: [hackStart - sweepEnd]).				sz = 5			ifTrue: [				"no hack"				percent at: incr put: 0.				(parsedData at: 5) at: incr put: gcEnd - hackStart]			ifFalse: 				[hackEnd = 0 					"no compaction"					ifTrue: [percent at: incr put: 0.						 	(parsedData at: 5) at: incr put: 0.							(parsedData at: 6) at: incr put: 0.							(parsedData at: 7) at: incr put: gcEnd - hackStart]					ifFalse: [(parsedData at: 5) at: incr put: hackEnd - hackStart.				 			 (parsedData at: 6) at: incr put: hackUpdateEnd - hackEnd.							 percent at: incr put: ((parsedData at: 6) at: incr) / ( ((parsedData at: 4) at: incr) + ((parsedData at: 6) at: incr)).				 			 (parsedData at: 7) at: incr put: gcEnd - hackUpdateEnd.]].		 incr := incr + 1.].		^  {'num full GCs' . numGCEnd - numGCStart. '		MarkTime' . (self stat: (parsedData at: 1)).'		ScavengeTime' . (self stat: (parsedData at: 2)). 's		SweepTime' . (self stat: (parsedData at: 3)). '		SelectiveCompaction' . (self stat: (parsedData at: 4)). ' 		HackOr0' . sz = 5 ifTrue: [0] ifFalse: [(self stat: (parsedData at: 5))]. '		UpdateOr0' . sz = 5 ifTrue: [0] ifFalse: [(self stat: (parsedData at: 6))]. '		Update%OfPause' . (self stat: percent). '		Remain'.  sz = 5 ifTrue: [(self stat: (parsedData at: 5))] ifFalse: [(self stat: (parsedData at: 7))].'		Hack enabled' . (Smalltalk vm parameterAt: 76).'		Exec time'. time .		'Mark time' . markTimeEnd - markTimeStart}! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GCBenchEvaluatorV2 class	instanceVariableNames: ''!!GCBenchEvaluatorV2 class methodsFor: 'as yet unclassified' stamp: 'ClementBera 9/24/2018 11:38'!runTracking: iteration project: project	"0, #wildfly for example"	self run: iteration project: project trackingIndex: 1 fileName: 'Tracking-' , project , '-' , iteration asString , '.txt'! !!GCBenchEvaluatorV2 class methodsFor: 'as yet unclassified' stamp: 'ClementBera 9/24/2018 11:00'!run: iteration project: project trackingIndex: index fileName: fileName	| b ev |	b := GCMooseBench new.	ev := GCBenchEvaluatorV2 new.	Smalltalk vm parameterAt: 76 put: index.	(FileStream fileNamed: fileName) << {	'	load'.	ev bench: [b benchLoadFromMSE: (b perform: project)].	'	exp'.	ev bench: [b benchExpandProperties]. 	'	expWCache'.	ev bench: [b benchExpandProperties]. 	'	expRelease'.	ev bench: [b benchRelease]} asString.! !!GCBenchEvaluatorV2 class methodsFor: 'as yet unclassified' stamp: 'ClementBera 9/24/2018 12:59'!runSelective: iteration project: project	self run: iteration project: project trackingIndex: 1 fileName: 'Selective-' , project , '-' , iteration asString , '.txt'! !GCBenchConfigurator subclass: #GCBenchOptions	instanceVariableNames: 'accessMemory benchmarkDuration dataObjects maxLiveness maxSize readOnlyAccess timeQuantum classes weakStructures compiledMethods stateOfHeap'	classVariableNames: ''	poolDictionaries: ''	category: 'CogTools-GCBenchGenerator'!!GCBenchOptions methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 14:34'!accessMemory: aBoolean	accessMemory := aBoolean! !!GCBenchOptions methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 14:34'!accessMemory	^ accessMemory! !!GCBenchOptions methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 14:29'!benchmarkDuration: anInteger		benchmarkDuration := anInteger! !!GCBenchOptions methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 14:41'!checkCorrectness	"check the correctness of options"		self assert: ['minLiveness'<= maxLiveness] description: 'The minimum liveness is greater than the maximum liveness'.	self assert: ['minSize'<= maxSize] description: 'The minimum size is greater than the maximum size'.	'add assert for percentages between object types	add assert for max allocated size'		! !!GCBenchOptions methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 14:29'!timeQuantum	^ timeQuantum! !!GCBenchOptions methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 15:41'!stateOfHeap: anInteger	stateOfHeap := anInteger! !!GCBenchOptions methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 15:43'!initializeDefaultOptions	"sets the value of options by default. Each of these options can be modified in the dedicated methods"		timeQuantum := 1048576.	benchmarkDuration := 100.	maxLiveness := 10.	maxSize := 64.	accessMemory := true . 	readOnlyAccess := false.	dataObjects := 0.25. "in percentage of total objects allocated"	classes := 0.25. 	weakStructures := 0.25.	compiledMethods := 0.25.	stateOfHeap := 0. "-1 = shrinking, 0 = stable, 2 = growing"! !!GCBenchOptions methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 14:58'!dataObjects	^ dataObjects! !!GCBenchOptions methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 14:58'!weakStructures	^ weakStructures! !!GCBenchOptions methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 14:29'!benchmarkDuration		^benchmarkDuration! !!GCBenchOptions methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 15:41'!setValuesForAccessMemory: access benchmarkDuration: duration dataObjects: percDataObj readOnlyAccess: readOnly timeQuantum: tq classes: percClasses weakStructures: percWeak compiledMethods: percCompiledMeth stateOfHeap: stateHeap	accessMemory:= access. 	benchmarkDuration:= duration .	dataObjects:= percDataObj. 	readOnlyAccess:= readOnly. 	timeQuantum:= tq. 	classes:= percClasses. 	weakStructures:= percWeak. 	compiledMethods:= percCompiledMeth.	stateOfHeap := stateHeap		! !!GCBenchOptions methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 14:29'!timeQuantum: anInteger	timeQuantum := anInteger! !!GCBenchOptions methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 14:58'!classes	^ classes! !!GCBenchOptions methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 14:58'!compiledMethods	^ compiledMethods! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GCBenchOptions class	instanceVariableNames: ''!!GCBenchOptions class methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 14:42'!default		^ GCBenchOptions new		initializeDefaultOptions;		checkCorrectness.		! !!GCBenchOptions class methodsFor: 'as yet unclassified' stamp: 'sk 6/13/2018 15:42'!fullCustomForAccessMemory: access benchmarkDuration: duration dataObjects: percDataObj readOnlyAccess: readOnly timeQuantum: tq classes: percClasses weakStructures: percWeak compiledMethods: percCompiledMeth stateOfHeap: stateHeap		^ GCBenchOptions new		setValuesForAccessMemory: access benchmarkDuration: duration dataObjects: percDataObj readOnlyAccess: readOnly timeQuantum: tq classes: percClasses weakStructures: percWeak compiledMethods: percCompiledMeth stateOfHeap: stateHeap;		checkCorrectness.		! !Object subclass: #GCMooseBench	instanceVariableNames: 'mooseModel allProperties'	classVariableNames: ''	poolDictionaries: ''	category: 'CogTools-GCBenchGenerator'!!GCMooseBench commentStamp: 'ClementBera 6/12/2018 09:59' prior: 0!GC Benchmarks using Moose.Set-up: acquiring a model:model := (b benchLoadFromMSE: b wildfly) mooseModel.Growing heap:[GCMooseBench new benchLoadFromMSE: b wildfly].[(GCMooseBench withMooseModel: model) benchExpandProperties]. "optional, increases drastically the model size"Stable heap:[(GCMooseBench withMooseModel: model) benchAnalysisPyramid].[(GCMooseBench withMooseModel: model) benchAnalysisSymbol].[(GCMooseBench withMooseModel: model) benchAnalysisDeprecation].Shrinking heap:[(GCMooseBench withMooseModel: model) benchRelease].!!GCMooseBench methodsFor: 'bench-stable' stamp: 'ClementBera 6/12/2018 09:58'!benchAnalysisDeprecation	mooseModel allModelClasses select: [ :each |    		(each isAnnotatedWith: 'Deprecated') and: [ each clientTypes notEmpty ] ].! !!GCMooseBench methodsFor: 'bench-stable' stamp: 'ClementBera 6/12/2018 09:58'!benchAnalysisSymbol	mooseModel allMethods symbolsUsedInName! !!GCMooseBench methodsFor: 'bench-stable' stamp: 'ClementBera 6/12/2018 09:58'!benchAnalysisPyramid	mooseModel overviewPyramidMetrics.! !!GCMooseBench methodsFor: 'mse files' stamp: 'ClementBera 10/3/2018 18:16'!netBeans	^ 'netbeans.mse'! !!GCMooseBench methodsFor: 'mse files' stamp: 'ClementBera 10/3/2018 18:16'!lucene	^ 'lucene.mse'! !!GCMooseBench methodsFor: 'mse files' stamp: 'ClementBera 10/3/2018 18:16'!wildfly	^ 'wildfly.mse'! !!GCMooseBench methodsFor: 'mse files' stamp: 'ClementBera 10/3/2018 18:16'!spring	^ 'spring.mse'! !!GCMooseBench methodsFor: 'accessing' stamp: 'ClementBera 6/12/2018 09:55'!mooseModel	^ mooseModel ! !!GCMooseBench methodsFor: 'accessing' stamp: 'ClementBera 6/12/2018 09:48'!mooseModel: anObject	mooseModel := anObject! !!GCMooseBench methodsFor: 'bench-shrink' stamp: 'ClementBera 6/12/2018 09:51'!benchRelease	mooseModel := nil.	allProperties := nil.	3 timesRepeat: [Smalltalk garbageCollect].! !!GCMooseBench methodsFor: 'bench-growing' stamp: 'ClementBera 6/14/2018 14:11'!benchLocalProperties	mooseModel entityStorage do: [ :anEntity |     		anEntity mooseInterestingEntity complexPropertyPragmas collect: [ :aPragma |        		[ (anEntity mooseInterestingEntity perform: aPragma methodSelector) ] on: Error do: ['error'] ] ].! !!GCMooseBench methodsFor: 'bench-growing' stamp: 'ClementBera 7/31/2018 15:37'!benchExpandProperties	"allProperties :=" mooseModel entityStorage do: [ :anEntity |     		anEntity mooseInterestingEntity complexPropertyPragmas do: [ :aPragma |        		[ (anEntity mooseInterestingEntity perform: aPragma methodSelector) ] on: Error do: ['error'] ] ].! !!GCMooseBench methodsFor: 'bench-growing' stamp: 'ClementBera 10/3/2018 18:16'!benchLoadFromMSE: fileName	mooseModel := MooseModel new importFromMSEStream: (StandardFileStream readOnlyFileNamed: '../WorkLoads/' , fileName)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GCMooseBench class	instanceVariableNames: ''!!GCMooseBench class methodsFor: 'instance creation' stamp: 'ClementBera 6/12/2018 09:48'!withMooseModel: model	^ self new		mooseModel: model;		yourself! !!GCMooseBench class methodsFor: 'instance creation' stamp: 'ClementBera 6/14/2018 17:47'!runAll	| b f res block numRuns names |	numRuns := 5.	b := GCMooseBench new.	f := FileStream newFileNamed: 'benchRes'.	f cr.	block := [Smalltalk garbageCollect.			 Smalltalk vm parameterAt: 3].	#(wildfly lucene spring) do: [ :mse |		FileStream stdout << mse.		FileStream stdout cr.		f << mse.		f cr.		1 to: numRuns do: [:i |		FileStream stdout << 'Run' << i printString.		FileStream stdout cr.		f << 'Run ' << i printString.		f cr.		res := {			block value.			GCBenchEvaluator evaluate: [b benchLoadFromMSE: (b perform: mse)].			block value.			"GCBenchEvaluator evaluate: [b benchAnalysisPyramid].			block value.			GCBenchEvaluator evaluate: [b benchAnalysisSymbol].			block value.			GCBenchEvaluator evaluate: [b benchAnalysisDeprecation].			block value."			GCBenchEvaluator evaluate: [b benchLocalProperties].			block value.			GCBenchEvaluator evaluate: [b benchLocalProperties].			block value.			"GCBenchEvaluator evaluate: [b benchExpandProperties].			block value."			GCBenchEvaluator evaluate: [b benchRelease].			block value }.		names := #(Load LocalProperties LocalPropertiesCached Release).		1 to: names size do: [ :j |			f << (names at: j).			f cr.			f << (res at: j * 2) printString.			f cr.			f << (res at: j * 2 - 1) printString.			f << ' -> '.			f << (res at: j * 2 + 1) printString.			f cr ].		f cr ] ].! !!GCMooseBench class methodsFor: 'instance creation' stamp: 'ClementBera 6/15/2018 09:54'!run: mse num: i	| b f res block numRuns names |	numRuns := 5.	b := GCMooseBench new.	f := FileStream newFileNamed: 'benchRes' , mse , i printString.	f cr.	block := [Smalltalk garbageCollect.						FileStream stdout << 'next'.			 Smalltalk vm parameterAt: 3].	"#(wildfly lucene spring) do: [ :mse |"		FileStream stdout << mse.		FileStream stdout cr.		f << mse.		f cr.		"1 to: numRuns do: [:i |"		FileStream stdout << 'Run' << i printString.		FileStream stdout cr.		f << 'Run ' << i printString.		f cr.		res := {			block value.			GCBenchEvaluator evaluate: [b benchLoadFromMSE: (b perform: mse)].			block value.			"GCBenchEvaluator evaluate: [b benchAnalysisPyramid].			block value.			GCBenchEvaluator evaluate: [b benchAnalysisSymbol].			block value.			GCBenchEvaluator evaluate: [b benchAnalysisDeprecation].			block value."			GCBenchEvaluator evaluate: [b benchLocalProperties].			block value.			GCBenchEvaluator evaluate: [b benchLocalProperties].			block value.			"GCBenchEvaluator evaluate: [b benchExpandProperties].			block value."			GCBenchEvaluator evaluate: [b benchRelease].			block value }.		names := #(Load LocalProperties LocalPropertiesCached Release).		1 to: names size do: [ :j |			f << (names at: j).			f cr.			f << (res at: j * 2) printString.			f cr.			f << (res at: j * 2 - 1) printString.			f << ' -> '.			f << (res at: j * 2 + 1) printString.			f cr ].		f cr "] ]."! !Smalltalk snapshot: true andQuit: true!